{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>EllarSQL is an SQL database Ellar Module.</p> <p> </p> <p>EllarSQL is an SQL database module, leveraging the robust capabilities of SQLAlchemy to  seamlessly interact with SQL databases through Python code and objects.</p> <p>EllarSQL is meticulously designed to streamline the integration of SQLAlchemy within your  Ellar application. It introduces discerning usage patterns around pivotal objects  such as model, session, and engine, ensuring an efficient and coherent workflow.</p> <p>Notably, EllarSQL refrains from altering the fundamental workings or usage of SQLAlchemy.  This documentation is focused on the meticulous setup of EllarSQL. For an in-depth exploration of SQLAlchemy,  we recommend referring to the comprehensive SQLAlchemy documentation.</p>"},{"location":"#feature-highlights","title":"Feature Highlights","text":"<p>EllarSQL comes packed with a set of awesome features designed:</p> <ul> <li> <p>Migration: Enjoy an async-first migration solution that seamlessly handles both single and multiple database setups and for both async and sync database engines configuration.</p> </li> <li> <p>Single/Multiple Database: EllarSQL provides an intuitive setup for models with different databases, allowing you to manage your data across various sources effortlessly.</p> </li> <li> <p>Pagination: EllarSQL introduces SQLAlchemy Paginator for API/Templated routes, along with support for other fantastic SQLAlchemy pagination tools.</p> </li> <li> <p>Unlimited Compatibility: EllarSQL plays nice with the entire SQLAlchemy ecosystem. Whether you're using third-party tools or exploring the vast SQLAlchemy landscape, EllarSQL seamlessly integrates with your preferred tooling.</p> </li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>EllarSQL core dependencies includes:</p> <ul> <li>Python &gt;= 3.8</li> <li>Ellar &gt;= 0.6.7</li> <li>SQLAlchemy &gt;= 2.0.16</li> <li>Alembic &gt;= 1.10.0</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install ellar-sql\n</code></pre> <p>OR if you intend to work with Async SQLAlchemy packages, then: </p> <pre><code>pip install ellar-sql[async]\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Let's create a simple <code>User</code> model. <pre><code>from ellar_sql import model\n\n\nclass User(model.Model):\n    id: model.Mapped[int] = model.mapped_column(model.Integer, primary_key=True)\n    username: model.Mapped[str] = model.mapped_column(model.String, unique=True, nullable=False)\n    email: model.Mapped[str] = model.mapped_column(model.String)\n</code></pre> Let's create <code>app.db</code> with <code>User</code> table in it. For that we need to set up <code>EllarSQLService</code> as shown below:</p> <p><pre><code>from ellar_sql import EllarSQLService\n\ndb_service = EllarSQLService(\n    databases='sqlite:///app.db', \n    echo=True, \n)\n\ndb_service.create_all()\n</code></pre> If you check your execution directory, you will see <code>sqlite</code> directory with <code>app.db</code>.</p> <p>Let's populate our <code>User</code> table. To do, we need a session, which is available at <code>db_service.session_factory</code></p> <pre><code>from ellar_sql import EllarSQLService, model\n\n\nclass User(model.Model):\n    id: model.Mapped[int] = model.mapped_column(model.Integer, primary_key=True)\n    username: model.Mapped[str] = model.mapped_column(model.String, unique=True, nullable=False)\n    email: model.Mapped[str] = model.mapped_column(model.String)\n\n\ndb_service = EllarSQLService(\n    databases='sqlite:///app.db',\n    echo=True,\n)\n\ndb_service.create_all()\n\nsession = db_service.session_factory()\n\nfor i in range(50):\n    session.add(User(username=f'username-{i+1}', email=f'user{i+1}doe@example.com'))\n\n\nsession.commit()\nrows = session.execute(model.select(User)).scalars()\n\nall_users = [row.dict() for row in rows]\nassert len(all_users) == 50\n\nsession.close()\n</code></pre> <p>We have successfully seed <code>50</code> users to <code>User</code> table in <code>app.db</code>. </p> <p>You can find the source code  for this example  here.</p> <p>I know at this point you want to know more, so let's dive deep into the documents and get started.</p>"},{"location":"migrations/","title":"Migrations","text":"<p>EllarSQL also extends Alembic package to add migration functionality and make database operations accessible through EllarCLI commandline interface.</p> <p>EllarSQL with Alembic does not override Alembic action rather provide Alembic all the configs/information it needs to for a proper migration/database operations. Its also still possible to use Alembic outside EllarSQL setup when necessary.</p> <p>This section is inspired by <code>Flask Migrate</code></p>"},{"location":"migrations/#quick-example","title":"Quick Example","text":"<p>We assume you have set up <code>EllarSQLModule</code> in your application, and you have specified <code>migration_options</code>.</p> <p>Create a simple <code>User</code> model as shown below:</p> <pre><code>from ellar_sql import model\n\n\nclass User(model.Model):\n    id = model.Column(model.Integer, primary_key=True)\n    name = model.Column(model.String(128))\n</code></pre>"},{"location":"migrations/#initialize-migration-template","title":"Initialize migration template","text":"<p>With the Model setup, run the command below</p> <pre><code># Initialize the database\nellar db init\n</code></pre> <p>Executing this command will incorporate a migrations folder into your application structure.  Ensure that the contents of this folder are included in version control alongside your other source files.</p> <p>Following the initialization, you can generate an initial migration using the command:</p> <p><pre><code># Generate the initial migration\nellar db migrate -m \"Initial migration.\"\n</code></pre> Few things to do after generating a migration file:</p> <ul> <li>Review and edit the migration script</li> <li>Alembic may not detect certain changes automatically, such as table and column name modifications or unnamed constraints. Refer to the Alembic autogenerate documentation for a comprehensive list of limitations.</li> <li>Add the finalized migration script to version control</li> <li>Ensure that the edited script is committed along with your source code changes</li> </ul> <p>Apply the changes described in the migration script to your database</p> <pre><code>ellar db upgrade\n</code></pre> <p>Whenever there are changes to the database models, it's necessary to repeat the <code>migrate</code> and <code>upgrade</code> commands.</p> <p>For synchronizing the database on another system, simply refresh the migrations folder from the source control repository  and execute the <code>upgrade</code> command. This ensures that the database structure aligns with the latest changes in the models.</p>"},{"location":"migrations/#multiple-database-migration","title":"Multiple Database Migration","text":"<p>If your application utilizes multiple databases, a distinct Alembic template for migration is required.  To enable this, include <code>-m</code> or <code>--multi</code> with the <code>db init</code> command, as demonstrated below:</p> <pre><code>ellar db init --multi\n</code></pre>"},{"location":"migrations/#command-reference","title":"Command Reference","text":"<p>All Alembic commands are expose to Ellar CLI under <code>db</code> group after a successful <code>EllarSQLModule</code> setup.</p> <p>To see all the commands that are available run this command: <pre><code>ellar db --help\n\n# output\nUsage: ellar db [OPTIONS] COMMAND [ARGS]...\n\n  - Perform Alembic Database Commands -\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  branches   - Show current branch points\n  check      Check if there are any new operations to migrate\n  current    - Display the current revision for each database.\n  downgrade  - Revert to a previous version\n  edit       - Edit a revision file\n  heads      - Show current available heads in the script directory\n  history    - List changeset scripts in chronological order.\n  init       Creates a new migration repository.\n  merge      - Merge two revisions together, creating a new revision file\n  migrate    - Autogenerate a new revision file (Alias for 'revision...\n  revision   - Create a new revision file.\n  show       - Show the revision denoted by the given symbol.\n  stamp      - 'stamp' the revision table with the given revision; don't...\n  upgrade    - Upgrade to a later version\n</code></pre></p> <ul> <li> <p><code>ellar db --help</code>    Shows a list of available commands.</p> </li> <li> <p><code>ellar db revision [--message MESSAGE] [--autogenerate] [--sql] [--head HEAD] [--splice] [--branch-label BRANCH_LABEL] [--version-path VERSION_PATH] [--rev-id REV_ID]</code>   Creates an empty revision script. The script needs to be edited manually with the upgrade and downgrade changes. See Alembic\u2019s documentation for instructions on how to write migration scripts. An optional migration message can be included.</p> </li> <li> <p><code>ellar db migrate [--message MESSAGE] [--sql] [--head HEAD] [--splice] [--branch-label BRANCH_LABEL] [--version-path VERSION_PATH] [--rev-id REV_ID]</code>   Equivalent to revision --autogenerate. The migration script is populated with changes detected automatically. The generated script should be reviewed and edited as not all types of changes can be detected automatically. This command does not make any changes to the database, just creates the revision script.</p> </li> <li> <p><code>ellar db check</code>   Checks that a migrate command would not generate any changes. If pending changes are detected, the command exits with a non-zero status code.</p> </li> <li> <p><code>ellar db edit &lt;revision&gt;</code>   Edit a revision script using $EDITOR.</p> </li> <li> <p><code>ellar db upgrade [--sql] [--tag TAG] &lt;revision&gt;</code>   Upgrades the database. If revision isn\u2019t given, then \"head\" is assumed.</p> </li> <li> <p><code>ellar db downgrade [--sql] [--tag TAG] &lt;revision&gt;</code>   Downgrades the database. If revision isn\u2019t given, then -1 is assumed.</p> </li> <li> <p><code>ellar db stamp [--sql] [--tag TAG] &lt;revision&gt;</code>   Sets the revision in the database to the one given as an argument, without performing any migrations.</p> </li> <li> <p><code>ellar db current [--verbose]</code>   Shows the current revision of the database.</p> </li> <li> <p><code>ellar db history [--rev-range REV_RANGE] [--verbose]</code>   Shows the list of migrations. If a range isn\u2019t given, then the entire history is shown.</p> </li> <li> <p><code>ellar db show &lt;revision&gt;</code>   Show the revision denoted by the given symbol.</p> </li> <li> <p><code>ellar db merge [--message MESSAGE] [--branch-label BRANCH_LABEL] [--rev-id REV_ID] &lt;revisions&gt;</code>   Merge two revisions together. Create a new revision file.</p> </li> <li> <p><code>ellar db heads [--verbose] [--resolve-dependencies]</code>   Show current available heads in the revision script directory.</p> </li> <li> <p><code>ellar db branches [--verbose]</code>   Show current branch points.</p> </li> </ul>"},{"location":"migrations/env/","title":"Alembic Env","text":"<p>In the generated migration template, EllarSQL adopts an async-first approach for handling migration file generation.  This approach simplifies the execution of migrations for both <code>Session</code>, <code>Engine</code>, <code>AsyncSession</code>, and <code>AsyncEngine</code>,  but it also introduces a certain level of complexity.</p> <pre><code>from logging.config import fileConfig\n\nfrom alembic import context\nfrom ellar.core import current_injector\nfrom ellar.threading import run_as_sync\n\nfrom ellar_sql.migrations import SingleDatabaseAlembicEnvMigration\nfrom ellar_sql.services import EllarSQLService\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nfileConfig(config.config_file_name)  # type:ignore[arg-type]\n\n# logger = logging.getLogger(\"alembic.env\")\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n@run_as_sync\nasync def main() -&gt; None:\n    db_service: EllarSQLService = current_injector.get(EllarSQLService)\n\n    # initialize migration class\n    alembic_env_migration = SingleDatabaseAlembicEnvMigration(db_service)\n\n    if context.is_offline_mode():\n        alembic_env_migration.run_migrations_offline(context)  # type:ignore[arg-type]\n    else:\n        await alembic_env_migration.run_migrations_online(context)  # type:ignore[arg-type]\n\n\nmain()\n</code></pre> <p>The EllarSQL migration package provides two main migration classes:</p> <ul> <li>SingleDatabaseAlembicEnvMigration: Manages migrations for a single database configuration, catering to both <code>Engine</code> and <code>AsyncEngine</code>.</li> <li>MultipleDatabaseAlembicEnvMigration: Manages migrations for multiple database configurations, covering both <code>Engine</code> and <code>AsyncEngine</code>.</li> </ul>"},{"location":"migrations/env/#customizing-the-env-file","title":"Customizing the Env file","text":"<p>To customize or edit the Env file, it is recommended to inherit from either <code>SingleDatabaseAlembicEnvMigration</code> or <code>MultipleDatabaseAlembicEnvMigration</code> based on your specific configuration. Make the necessary changes within the inherited class.</p> <p>If you prefer to write something from scratch, then the abstract class <code>AlembicEnvMigrationBase</code> is the starting point. This class includes three abstract methods and expects a <code>EllarSQLService</code> during initialization, as demonstrated below:</p> <pre><code>class AlembicEnvMigrationBase:\n    def __init__(self, db_service: EllarSQLService) -&gt; None:\n        self.db_service = db_service\n        self.use_two_phase = db_service.migration_options.use_two_phase\n\n    @abstractmethod\n    def default_process_revision_directives(\n        self,\n        context: \"MigrationContext\",\n        revision: RevisionArgs,\n        directives: t.List[\"MigrationScript\"],\n    ) -&gt; t.Any:\n        pass\n\n    @abstractmethod\n    def run_migrations_offline(self, context: \"EnvironmentContext\") -&gt; None:\n        pass\n\n    @abstractmethod\n    async def run_migrations_online(self, context: \"EnvironmentContext\") -&gt; None:\n        pass\n</code></pre> <p>The <code>run_migrations_online</code> and <code>run_migrations_offline</code> are all similar to the same function from Alembic env.py template. The <code>default_process_revision_directives</code> is a callback is used to prevent an auto-migration from being generated  when there are no changes to the schema described in details here</p>"},{"location":"migrations/env/#example","title":"Example","text":"<pre><code>import logging\nfrom logging.config import fileConfig\n\nfrom alembic import context\nfrom ellar_sql.migrations import AlembicEnvMigrationBase\nfrom ellar_sql.model.database_binds import get_metadata\nfrom ellar.core import current_injector\nfrom ellar.threading import run_as_sync\nfrom ellar_sql.services import EllarSQLService\n\n# This is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\nlogger = logging.getLogger(\"alembic.env\")\n# Interpret the config file for Python logging.\n# This line sets up loggers essentially.\nfileConfig(config.config_file_name)  # type:ignore[arg-type]\n\nclass MyCustomMigrationEnv(AlembicEnvMigrationBase):\n    def default_process_revision_directives(\n        self,\n        context,\n        revision,\n        directives,\n    ) -&gt; None:\n        if getattr(context.config.cmd_opts, \"autogenerate\", False):\n            script = directives[0]\n            if script.upgrade_ops.is_empty():\n                directives[:] = []\n                logger.info(\"No changes in schema detected.\")\n\n    def run_migrations_offline(self, context: \"EnvironmentContext\") -&gt; None:\n        \"\"\"Run migrations in 'offline' mode.\n\n        This configures the context with just a URL\n        and not an Engine, though an Engine is acceptable\n        here as well.  By skipping the Engine creation\n        we don't even need a DBAPI to be available.\n\n        Calls to context.execute() here emit the given string to the\n        script output.\n\n        \"\"\"\n        pass\n\n    async def run_migrations_online(self, context: \"EnvironmentContext\") -&gt; None:\n        \"\"\"Run migrations in 'online' mode.\n\n        In this scenario, we need to create an Engine\n        and associate a connection with the context.\n\n        \"\"\"\n        key, engine = self.db_service.engines.popitem()\n        metadata = get_metadata(key, certain=True).metadata\n\n        conf_args = {}\n        conf_args.setdefault(\n            \"process_revision_directives\", self.default_process_revision_directives\n        )\n\n        with engine.connect() as connection:\n            context.configure(\n                connection=connection,\n                target_metadata=metadata,\n                **conf_args\n            )\n\n            with context.begin_transaction():\n                context.run_migrations()\n\n\n@run_as_sync\nasync def main() -&gt; None:\n    db_service: EllarSQLService = current_injector.get(EllarSQLService)\n\n    # initialize migration class\n    alembic_env_migration = MyCustomMigrationEnv(db_service)\n\n    if context.is_offline_mode():\n        alembic_env_migration.run_migrations_offline(context)\n    else:\n        await alembic_env_migration.run_migrations_online(context)\n\nmain()\n</code></pre> <p>This migration environment class, <code>MyCustomMigrationEnv</code>, inherits from <code>AlembicEnvMigrationBase</code>  and provides the necessary methods for offline and online migrations.  It utilizes the <code>EllarSQLService</code> to obtain the database engines and metadata for the migration process.  The <code>main</code> function initializes and executes the migration class, with specific handling for offline and online modes.</p>"},{"location":"models/","title":"Models and Tables","text":"<p>The <code>ellar_sql.model.Model</code> class acts as a factory for creating <code>SQLAlchemy</code> models, and  associating the generated models with the corresponding Metadata through their designated <code>__database__</code> key.</p> <p>This class can be configured through the <code>__base_config__</code> attribute, allowing you to specify how your <code>SQLAlchemy</code> model should be created.  The <code>__base_config__</code> attribute can be of type <code>ModelBaseConfig</code>, which is a dataclass, or a dictionary with keys that  match the attributes of <code>ModelBaseConfig</code>.</p> <p>Attributes of <code>ModelBaseConfig</code>:</p> <ul> <li>as_base: Indicates whether the class should be treated as a <code>Base</code> class for other model definitions, similar to creating a Base from a DeclarativeBase or DeclarativeBaseNoMeta class. (Default: False)</li> <li>use_base: Specifies the base classes that will be used to create the <code>SQLAlchemy</code> model. (Default: [])</li> </ul>"},{"location":"models/#creating-a-base-class","title":"Creating a Base Class","text":"<p><code>Model</code> treats each model as a standalone entity. Each instance of <code>model.Model</code> creates a distinct declarative base for itself, using the <code>__database__</code> key as a reference to determine its associated Metadata. Consequently, models sharing the same <code>__database__</code> key will utilize the same Metadata object.</p> <p>Let's explore how we can create a <code>Base</code> model using <code>Model</code>, similar to the approach in traditional <code>SQLAlchemy</code>.</p> <pre><code>from ellar_sql import model, ModelBaseConfig\n\n\nclass Base(model.Model):\n    __base_config__ = ModelBaseConfig(as_base=True, use_bases=[model.DeclarativeBase])\n\n\nassert issubclass(Base, model.DeclarativeBase)\n</code></pre> <p>If you are interested in SQLAlchemy\u2019s native support for data classes,  then you can add <code>MappedAsDataclass</code> to <code>use_bases</code> as shown below:</p> <pre><code>from ellar_sql import model, ModelBaseConfig\n\n\nclass Base(model.Model):\n    __base_config__ = ModelBaseConfig(as_base=True, use_bases=[model.DeclarativeBase, model.MappedAsDataclass])\n\nassert issubclass(Base, model.MappedAsDataclass)\n</code></pre> <p>In the examples above, <code>Base</code> classes are created, all subclassed from the <code>use_bases</code> provided, and with the <code>as_base</code>  option, the factory creates the <code>Base</code> class as a <code>Base</code>.</p>"},{"location":"models/#create-base-with-metadata","title":"Create base with MetaData","text":"<p>You can also configure the SQLAlchemy object with a custom <code>MetaData</code> object.  For instance, you can define a specific naming convention for constraints, ensuring consistency and predictability in constraint names.  This can be particularly beneficial during migrations, as detailed by Alembic.</p> <p>For example:</p> <pre><code>from ellar_sql import model, ModelBaseConfig\n\nclass Base(model.Model):\n    __base_config__ = ModelBaseConfig(as_base=True, use_bases=[model.DeclarativeBase])\n\n    metadata = model.MetaData(naming_convention={\n        \"ix\": 'ix_%(column_0_label)s',\n        \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n        \"ck\": \"ck_%(table_name)s_%(constraint_name)s\",\n        \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n        \"pk\": \"pk_%(table_name)s\"\n    })\n</code></pre>"},{"location":"models/#abstract-models-and-mixins","title":"Abstract Models and Mixins","text":"<p>If the desired behavior is only applicable to specific models rather than all models,  you can use an abstract model base class to customize only those models.  For example, if certain models need to track their creation or update timestamps, t his approach allows for targeted customization.</p> <pre><code>from datetime import datetime, timezone\nfrom ellar_sql import model\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nclass TimestampModel(model.Model):\n    __abstract__ = True\n    created: Mapped[datetime] = mapped_column(default=lambda: datetime.now(timezone.utc))\n    updated: Mapped[datetime] = mapped_column(default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))\n\n\nclass BookAuthor(model.Model):\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(unique=True)\n\n\nclass Book(TimestampModel):\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n</code></pre> <p>This can also be done with a mixin class, inherited separately. <pre><code>from datetime import datetime, timezone\nfrom ellar_sql import model\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nclass TimestampModel:\n    created: Mapped[datetime] = mapped_column(default=lambda: datetime.now(timezone.utc))\n    updated: Mapped[datetime] = mapped_column(default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))\n\n\nclass Book(model.Model, TimestampModel):\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n</code></pre></p>"},{"location":"models/#defining-models","title":"Defining Models","text":"<p>Unlike plain SQLAlchemy, EllarSQL models will automatically generate a table name if the <code>__tablename__</code> attribute is not set,  provided a primary key column is defined.</p> <p><pre><code>from ellar_sql import model\n\n\nclass User(model.Model):\n    id: model.Mapped[int] = model.mapped_column(primary_key=True)\n    username: model.Mapped[str] = model.mapped_column(unique=True)\n    email: model.Mapped[str]\n\n\nclass UserAddress(model.Model):\n    __tablename__ = 'user-address'\n    id: model.Mapped[int] = model.mapped_column(primary_key=True)\n    address: model.Mapped[str] = model.mapped_column(unique=True)\n\nassert User.__tablename__ == 'user'\nassert UserAddress.__tablename__ == 'user-address'\n</code></pre> For a comprehensive guide on defining model classes declaratively, refer to  SQLAlchemy\u2019s declarative documentation.  This resource provides detailed information and insights into the declarative approach for defining model classes.</p>"},{"location":"models/#defining-tables","title":"Defining Tables","text":"<p>The table class is designed to receive a table name, followed by columns and other table components such as constraints.</p> <p>EllarSQL enhances the functionality of the SQLAlchemy Table  by facilitating the selection of Metadata based on the <code>__database__</code> argument.</p> <p>Directly creating a table proves particularly valuable when establishing many-to-many relationships.  In such cases, the association table doesn't need its dedicated model class; rather, it can be conveniently accessed  through the relevant relationship attributes on the associated models.</p> <pre><code>from ellar_sql import model\n\nauthor_book_m2m = model.Table(\n    \"author_book\",\n    model.Column(\"book_author_id\", model.ForeignKey(BookAuthor.id), primary_key=True),\n    model.Column(\"book_id\", model.ForeignKey(Book.id), primary_key=True),\n)\n</code></pre>"},{"location":"models/#quick-tutorial","title":"Quick Tutorial","text":"<p>In this section, we'll delve into straightforward CRUD operations using the ORM objects.  However, if you're not well-acquainted with SQLAlchemy, feel free to explore their tutorial  on ORM for a more comprehensive understanding.</p> <p>Having understood, <code>Model</code> usage. Let's create a <code>User</code> model</p> <p><pre><code>from ellar_sql import model\n\n\nclass User(model.Model):\n    id: model.Mapped[int] = model.mapped_column(primary_key=True)\n    username: model.Mapped[str] = model.mapped_column(unique=True)\n    full_name: model.Mapped[str] = model.mapped_column(model.String)\n</code></pre> We have created a <code>User</code> model but the data does not exist. Let's fix that</p> <pre><code>from ellar.core import current_injector\nfrom ellar_sql import EllarSQLService\n\ndb_service = current_injector.get(EllarSQLService)\ndb_service.create_all()\n</code></pre>"},{"location":"models/#insert","title":"Insert","text":"<p>To insert data, you need a session. Here's an example using EllarSQL to insert a user:</p> <pre><code>import ellar.common as ecm\nfrom .model import User\n\n@ecm.post('/create')\ndef create_user():\n    session = User.get_db_session()\n    squidward = User(name=\"squidward\", fullname=\"Squidward Tentacles\")\n    session.add(squidward)\n\n    session.commit()\n\n    return squidward.dict(exclude={'id'})\n</code></pre> <p>In the above illustration, the <code>squidward</code> data is converted to a <code>dictionary</code> object by calling <code>.dict()</code>  and excluding the <code>id</code> field. The <code>User.get_db_session()</code> function is used to get the session  for the registered <code>EllarSQLService.session_factory</code>. The function depends on <code>ApplicationContext</code>.</p>"},{"location":"models/#update","title":"Update","text":"<p>To update, make changes to the ORM object and commit. Here's an example using EllarSQL to update a user:</p> <pre><code>import ellar.common as ecm\nimport sqlalchemy.orm as sa_orm\nfrom .model import User\n\n@ecm.put('/update')\ndef update_user(session: ecm.Inject[sa_orm.Session]):\n    squidward = session.get(User, 1)\n\n    squidward.fullname = 'EllarSQL'\n    session.commit()\n\n    return squidward.dict()\n</code></pre> <p>In the above illustration, <code>Inject[sa_orm.Session]</code> is used to inject the <code>session</code> into the <code>update_user</code> route handler.  This is another way to get the <code>session</code> through the <code>EllarSQLService</code> service. The changes made to the <code>squidward</code>  object are committed to the database using <code>session.commit()</code>.</p>"},{"location":"models/#delete","title":"Delete","text":"<p>To delete, pass the ORM object to <code>session.delete()</code>. <pre><code>import ellar.common as ecm\nimport sqlalchemy.orm as sa_orm\nfrom .model import User\n\n\n@ecm.delete('/delete')\ndef delete_user(session: ecm.Inject[sa_orm.Session]):\n    squidward = session.get(User, 1)\n\n    session.delete(squidward)\n    session.commit()\n\n    return ''\n</code></pre></p> <p>After modifying data, you must call <code>session.commit()</code> to commit the changes to the database. Otherwise, changes may not be persisted to the database.</p>"},{"location":"models/#view-utilities","title":"View Utilities","text":"<p>EllarSQL provides some utility query functions to check missing entities and raise 404 Not found if not found.</p> <ul> <li>get_or_404: It will raise a 404 error if the row with the given id does not exist; otherwise, it will return the corresponding instance.</li> <li>first_or_404: It will raise a 404 error if the query does not return any results; otherwise, it will return the first result.</li> <li>one_or_404(): It will raise a 404 error if the query does not return exactly one result; otherwise, it will return the result.</li> </ul> <pre><code>import ellar.common as ecm\nfrom ellar_sql import get_or_404, one_or_404, model\n\n@ecm.get(\"/user-by-id/{user_id:int}\")\nasync def user_by_id(user_id: int):\n    user = await get_or_404(User, user_id)\n    return user.dict()\n\n@ecm.get(\"/user-by-name/{name:str}\")\nasync def user_by_username(name: str):\n    user = await one_or_404(model.select(User).filter_by(name=name), error_message=f\"No user named '{name}'.\")\n    return user.dict()\n</code></pre>"},{"location":"models/#accessing-metadata-and-engines","title":"Accessing Metadata and Engines","text":"<p>In the process of <code>EllarSQLModule</code> setup, three services are registered to the Ellar IoC container.</p> <ul> <li><code>EllarSQLService</code>: Which manages models, metadata, engines and sessions</li> <li><code>Engine</code>: SQLAlchemy Engine of the default database configuration</li> <li><code>Session</code>SQLAlchemy Session of the default database configuration</li> </ul> <p>Although with <code>EllarSQLService</code> you can get the <code>engine</code> and <code>session</code>. It's there for easy of access.</p> <pre><code>import sqlalchemy as sa\nimport sqlalchemy.orm as sa_orm\nfrom ellar.core import current_injector\nfrom ellar_sql import EllarSQLService\n\ndb_service = current_injector.get(EllarSQLService)\n\nassert isinstance(db_service.engine, sa.Engine)\nassert isinstance(db_service.session_factory(), sa_orm.Session)\n</code></pre>"},{"location":"models/#important-constraints","title":"Important Constraints","text":"<ul> <li>EllarSQLModule <code>databases</code> options for <code>SQLAlchemy.ext.asyncio.AsyncEngine</code> will register <code>SQLAlchemy.ext.asyncio.AsyncEngine</code>   and <code>SQLAlchemy.ext.asyncio.AsyncSession</code></li> <li>EllarSQLModule <code>databases</code> options for <code>SQLAlchemy.Engine</code> will register <code>SQLAlchemy.Engine</code> and <code>SQLAlchemy.orm.Session</code>.</li> <li><code>EllarSQL.get_all_metadata()</code> retrieves all configured metadatas</li> <li><code>EllarSQL.get_metadata()</code> retrieves metadata by <code>__database__</code> key or <code>default</code> is no parameter is passed.</li> </ul> <p><pre><code>import sqlalchemy as sa\nimport sqlalchemy.orm as sa_orm\nfrom ellar.core import current_injector\n\n# get engine from DI\ndefault_engine = current_injector.get(sa.Engine)\n# get session from DI\nsession = current_injector.get(sa_orm.Session)\n\n\nassert isinstance(default_engine, sa.Engine)\nassert isinstance(session, sa_orm.Session)\n</code></pre> For Async Database options <pre><code>from sqlalchemy.ext.asyncio import AsyncSession, AsyncEngine\nfrom ellar.core import current_injector\n\n# get engine from DI\ndefault_engine = current_injector.get(AsyncEngine)\n# get session from DI\nsession = current_injector.get(AsyncSession)\n\n\nassert isinstance(default_engine, AsyncEngine)\nassert isinstance(session, AsyncSession)\n</code></pre></p>"},{"location":"models/extra-fields/","title":"Extra Column Types","text":"<p>EllarSQL comes with extra column type descriptor that will come in handy in your project. They include</p> <ul> <li>GUID</li> <li>IPAddress</li> </ul>"},{"location":"models/extra-fields/#guid-column","title":"GUID Column","text":"<p>GUID, Global Unique Identifier of 128-bit text string can be used as a unique identifier in a table. For applications that require a GUID type of primary, this can be a use resource.  It uses <code>UUID</code> type in Postgres and <code>CHAR(32)</code> in other SQL databases.</p> <pre><code>import uuid\nfrom ellar_sql import model\n\nclass Guid(model.Model):\n    id: model.Mapped[uuid.uuid4] = model.mapped_column(\n        \"id\",\n        model.GUID(),\n        nullable=False,\n        unique=True,\n        primary_key=True,\n        default=uuid.uuid4,\n    )\n</code></pre>"},{"location":"models/extra-fields/#ipaddress-column","title":"IPAddress Column","text":"<p><code>GenericIP</code> column type validates and converts column value to <code>ipaddress.IPv4Address</code> or <code>ipaddress.IPv6Address</code>. It uses <code>INET</code> type in Postgres and <code>CHAR(45)</code> in other SQL databases.</p> <pre><code>import typing as t\nimport ipaddress\nfrom ellar_sql import model\n\nclass IPAddress(model.Model):\n    id = model.Column(model.Integer, primary_key=True)\n    ip: model.Mapped[t.Union[ipaddress.IPv4Address, ipaddress.IPv6Address]] = model.Column(model.GenericIP)\n</code></pre>"},{"location":"models/file-fields/","title":"File &amp; Image Column Types","text":"<p>EllarSQL provides File and Image column type descriptors to attach files to your models. It integrates seamlessly with the Sqlalchemy-file and EllarStorage packages.</p>"},{"location":"models/file-fields/#filefield-column","title":"FileField Column","text":"<p><code>FileField</code> can handle any type of file, making it a versatile option for file storage in your database models.</p> <pre><code>from ellar_sql import model\n\nclass Attachment(model.Model):\n    __tablename__ = \"attachments\"\n\n    id: model.Mapped[int] = model.mapped_column(autoincrement=True, primary_key=True)\n    name: model.Mapped[str] = model.mapped_column(model.String(50), unique=True)\n    content: model.Mapped[model.typeDecorator.File] = model.mapped_column(model.typeDecorator.FileField)\n</code></pre>"},{"location":"models/file-fields/#imagefield-column","title":"ImageField Column","text":"<p><code>ImageField</code> builds on FileField, adding validation to ensure the uploaded file is a valid image. This guarantees that only image files are stored.</p> <pre><code>from ellar_sql import model\n\nclass Book(model.Model):\n    __tablename__ = \"books\"\n\n    id: model.Mapped[int] = model.mapped_column(autoincrement=True, primary_key=True)\n    title: model.Mapped[str] = model.mapped_column(model.String(100), unique=True)\n    cover: model.Mapped[model.typeDecorator.File] = model.mapped_column(\n        model.typeDecorator.ImageField(\n            thumbnail_size=(128, 128),\n        )\n    )\n</code></pre> <p>By setting <code>thumbnail_size</code>, an additional thumbnail image is created and saved alongside the original <code>cover</code> image. You can access the thumbnail via <code>book.cover.thumbnail</code>.</p> <p>Note: <code>ImageField</code> requires the <code>Pillow</code> package: <pre><code>pip install pillow\n</code></pre></p>"},{"location":"models/file-fields/#uploading-files","title":"Uploading Files","text":"<p>To handle where files are saved, EllarSQL's File and Image Fields require EllarStorage's <code>StorageModule</code> setup. For more details, refer to the <code>StorageModule</code> setup.</p>"},{"location":"models/file-fields/#saving-files","title":"Saving Files","text":"<p>EllarSQL supports <code>Starlette.datastructures.UploadFile</code> for Image and File Fields, simplifying file saving directly from requests.</p> <p>For example:</p> <pre><code>import ellar.common as ecm\nfrom ellar_sql import model\nfrom ..models import Book\nfrom .schema import BookSchema\n\n@ecm.Controller\nclass BooksController(ecm.ControllerBase):\n    @ecm.post(\"/\", response={201: BookSchema})\n    def create_book(\n        self,\n        title: ecm.Body[str],\n        cover: ecm.File[ecm.UploadFile],\n        session: ecm.Inject[model.Session],\n    ):\n        book = Book(title=title, cover=cover)\n        session.add(book)\n        session.commit()\n        session.refresh(book)\n        return book\n</code></pre>"},{"location":"models/file-fields/#retrieving-file-object","title":"Retrieving File Object","text":"<p>The object retrieved from an Image or File Field is an instance of <code>ellar_sql.model.typeDecorator.File</code>.</p> <pre><code>@ecm.get(\"/{book_id:int}\", response={200: BookSchema})\ndef get_book_by_id(\n    self,\n    book_id: int, \n    session: ecm.Inject[model.Session],\n):\n    book = session.execute(\n        model.select(Book).where(Book.id == book_id)\n    ).scalar_one()\n\n    assert book.cover.saved  # saved is True for a saved file\n    assert book.cover.file.read() is not None  # access file content\n\n    assert book.cover.filename is not None  # `unnamed` when no filename is provided\n    assert book.cover.file_id is not None  # UUID v4\n\n    assert book.cover.upload_storage == \"default\"\n    assert book.cover.content_type is not None\n\n    assert book.cover.uploaded_at is not None\n    assert len(book.cover.files) == 2  # original image and generated thumbnail image\n\n    return book\n</code></pre>"},{"location":"models/file-fields/#adding-more-information-to-a-saved-file-object","title":"Adding More Information to a Saved File Object","text":"<p>The File object behaves like a Python dictionary, allowing you to add custom metadata. Be careful not to overwrite default attributes used by the File object internally.</p> <pre><code>from ellar_sql.model.typeDecorator import File\nfrom ..models import Book\n\ncontent = File(open(\"./example.png\", \"rb\"), custom_key1=\"custom_value1\", custom_key2=\"custom_value2\")\ncontent[\"custom_key3\"] = \"custom_value3\"\nbook = Book(title=\"Dummy\", cover=content)\n\nsession.add(book)\nsession.commit()\nsession.refresh(book)\n\nassert book.cover.custom_key1 == \"custom_value1\"\nassert book.cover.custom_key2 == \"custom_value2\"\nassert book.cover[\"custom_key3\"] == \"custom_value3\"\n</code></pre>"},{"location":"models/file-fields/#extra-and-headers","title":"Extra and Headers","text":"<p><code>Apache-libcloud</code> allows you to store each object with additional attributes or headers.</p> <p>You can add extras and headers in two ways:</p>"},{"location":"models/file-fields/#inline-field-declaration","title":"Inline Field Declaration","text":"<p>You can specify these extras and headers directly in the field declaration:</p> <pre><code>from ellar_sql import model\n\nclass Attachment(model.Model):\n    __tablename__ = \"attachments\"\n\n    id: model.Mapped[int] = model.mapped_column(autoincrement=True, primary_key=True)\n    name: model.Mapped[str] = model.mapped_column(model.String(50), unique=True)\n    content: model.Mapped[model.typeDecorator.File] = model.mapped_column(model.typeDecorator.FileField(\n        extra={\n            \"acl\": \"private\",\n            \"dummy_key\": \"dummy_value\",\n            \"meta_data\": {\"key1\": \"value1\", \"key2\": \"value2\"},\n        },\n        headers={\n            \"Access-Control-Allow-Origin\": \"http://test.com\",\n            \"Custom-Key\": \"xxxxxxx\",\n        },\n    ))\n</code></pre>"},{"location":"models/file-fields/#in-file-object","title":"In File Object","text":"<p>Alternatively, you can set extras and headers in the File object itself:</p> <pre><code>from ellar_sql.model.typeDecorator import File\n\nattachment = Attachment(\n    name=\"Public document\",\n    content=File(DummyFile(), extra={\"acl\": \"public-read\"}),\n)\nsession.add(attachment)\nsession.commit()\nsession.refresh(attachment)\n\nassert attachment.content.file.object.extra[\"acl\"] == \"public-read\"\n</code></pre>"},{"location":"models/file-fields/#uploading-to-a-specific-storage","title":"Uploading to a Specific Storage","text":"<p>By default, files are uploaded to the <code>default</code> storage specified in <code>StorageModule</code>. You can change this by specifying a different <code>upload_storage</code> in the field declaration:</p> <p><pre><code>from ellar_sql import model\n\nclass Book(model.Model):\n    __tablename__ = \"books\"\n\n    id: model.Mapped[int] = model.mapped_column(autoincrement=True, primary_key=True)\n    title: model.Mapped[str] = model.mapped_column(model.String(100), unique=True)\n    cover: model.Mapped[model.typeDecorator.File] = model.mapped_column(\n        model.typeDecorator.ImageField(\n            thumbnail_size=(128, 128), upload_storage=\"bookstore\"\n        )\n    )\n</code></pre> Setting <code>upload_storage=\"bookstore\"</code> ensures that the book cover is uploaded to the <code>bookstore</code> container defined in <code>StorageModule</code>.</p>"},{"location":"models/file-fields/#multiple-files","title":"Multiple Files","text":"<p>A File or Image Field column can be configured to hold multiple files by setting <code>multiple=True</code>.</p> <p>For example:</p> <p><pre><code>import typing as t\nfrom ellar_sql import model\n\nclass Article(model.Model):\n    __tablename__ = \"articles\"\n\n    id: model.Mapped[int] = model.mapped_column(autoincrement=True, primary_key=True)\n    title: model.Mapped[str] = model.mapped_column(model.String(100), unique=True)\n    documents: model.Mapped[t.List[model.typeDecorator.File]] = model.mapped_column(\n        model.typeDecorator.FileField(multiple=True, upload_storage=\"documents\")\n    )\n</code></pre> The <code>Article</code> model's <code>documents</code> column will store a list of files, applying validators and processors to each file individually. The returned model is a list of File objects.</p>"},{"location":"models/file-fields/#saving-multiple-file-fields","title":"Saving Multiple File Fields","text":"<p>Saving multiple files is as simple as passing a list of file contents to the file field column. For example:</p> <pre><code>import typing as t\nimport ellar.common as ecm\nfrom ellar_sql import model\nfrom ..models import Article\nfrom .schema import ArticleSchema\n\n@ecm.Controller\nclass ArticlesController(ecm.ControllerBase):\n    @ecm.post(\"/\", response={201: ArticleSchema})\n    def create_article(\n        self,\n        title: ecm.Body[str],\n        documents: ecm.File[t.List[ecm.UploadFile]],\n        session: ecm.Inject[model.Session],\n    ):\n        article = Article(\n            title=title, documents=[\n                model.typeDecorator.File(\n                    content=\"Hello World\",\n                    filename=\"hello.txt\",\n                    content_type=\"text/plain\",\n                )\n            ] + documents\n        )\n        session.add(article)\n        session.commit()\n        session.refresh(article)\n        return article\n</code></pre>"},{"location":"models/file-fields/#see-also","title":"See Also","text":"<ul> <li>Validators</li> <li>Processors</li> </ul> <p>For a more comprehensive hands-on experience, check out the file-field-example project.</p>"},{"location":"multiple/","title":"Multiple Databases","text":"<p>SQLAlchemy has the capability to establish connections with multiple databases simultaneously, referring to these connections as \"binds.\"</p> <p>EllarSQL simplifies the management of binds by associating each engine with a short string identifier, <code>__database__</code>.  Subsequently, each model and table is linked to a <code>__database__</code>, and during a query,  the session selects the appropriate engine based on the <code>__database__</code> of the entity being queried.  In the absence of a specified <code>__database__</code>, the default engine is employed.</p>"},{"location":"multiple/#configuring-multiple-databases","title":"Configuring Multiple Databases","text":"<p>In EllarSQL, database configuration begins with the setup of the default database,  followed by additional databases, as exemplified in the <code>EllarSQLModule</code> configurations:</p> <pre><code>from ellar_sql import EllarSQLModule\n\nEllarSQLModule.setup(\n    databases={\n        \"default\": \"postgresql:///main\",\n        \"meta\": \"sqlite:////path/to/meta.db\",\n        \"auth\": {\n            \"url\": \"mysql://localhost/users\",\n            \"pool_recycle\": 3600,\n        },\n    },\n    migration_options={'directory': 'migrations'}\n)\n</code></pre>"},{"location":"multiple/#defining-models-and-tables-with-different-databases","title":"Defining Models and Tables with Different Databases","text":"<p>EllarSQL creates Metadata and an Engine for each configured database.  Models and tables associated with a specific <code>__database__</code> key are registered with the corresponding Metadata.  During a session query, the session employs the related <code>Engine</code>.</p> <p>To designate the database for a model, set the <code>__database__</code> class attribute.  Not specifying a <code>__database__</code> key is equivalent to setting it to <code>default</code>:</p>"},{"location":"multiple/#in-models","title":"In Models","text":"<p><pre><code>from ellar_sql import model\n\nclass User(model.Model):\n    __database__ = \"auth\"\n    id = model.Column(model.Integer, primary_key=True)\n</code></pre> Models inheriting from an already existing model will share the same <code>database</code> key unless they are overriden.</p> <p>Info</p> <p>Its importance to not that <code>model.Model</code> has <code>__database__</code> value equals <code>default</code></p>"},{"location":"multiple/#in-tables","title":"In Tables","text":"<p>To specify the database for a table, utilize the <code>__database__</code> keyword argument:</p> <pre><code>from ellar_sql import model\n\nuser_table = model.Table(\n    \"user\",\n    model.Column(\"id\", model.Integer, primary_key=True),\n    __database__=\"auth\",\n)\n</code></pre> <p>Info</p> <p>Ultimately, the session references the database key associated with the metadata or table, an association established during creation.  Consequently, changing the database key after creating a model or table has no effect.</p>"},{"location":"multiple/#creating-and-dropping-tables","title":"Creating and Dropping Tables","text":"<p>The <code>create_all()</code> and <code>drop_all()</code> methods operating are all part of the <code>EllarSQLService</code>. It also requires the <code>database</code> argument to target a specific database. </p> <pre><code># Create tables for all binds\nfrom ellar.core import current_injector\nfrom ellar_sql import EllarSQLService\n\ndb_service = current_injector.get(EllarSQLService)\n\n# Create tables for all configured databases\ndb_service.create_all()\n\n# Create tables for the 'default' and \"auth\" databases\ndb_service.create_all('default', \"auth\")\n\n# Create tables for the \"meta\" database\ndb_service.create_all(\"meta\")\n\n# Drop tables for the 'default' database\ndb_service.drop_all('default')\n</code></pre>"},{"location":"overview/","title":"Quick Start","text":"<p>In this segment, we will walk through the process of configuring EllarSQL within your Ellar application,  ensuring that all essential services are registered, configurations are set, and everything is prepared for immediate use.</p> <p>Before we delve into the setup instructions, it is assumed that you possess a comprehensive  understanding of how Ellar Modules  operate.</p>"},{"location":"overview/#installation","title":"Installation","text":"<p>Let us install all the required packages, assuming that your Python environment has been properly configured:</p>"},{"location":"overview/#for-existing-project","title":"For Existing Project:","text":"<pre><code>pip install ellar-sql\n</code></pre>"},{"location":"overview/#for-new-project","title":"For New Project:","text":"<pre><code>pip install ellar ellar-cli ellar-sql\n</code></pre> <p>After a successful package installation, we need to scaffold a new project using <code>ellar</code> cli tool <pre><code>ellar new db-learning\n</code></pre> This will scaffold <code>db-learning</code> project with necessary file structure shown below. <pre><code>path/to/db-learning/\n\u251c\u2500 db_learning/\n\u2502  \u251c\u2500 apps/\n\u2502  \u2502  \u251c\u2500 __init__.py\n\u2502  \u251c\u2500 core/\n\u2502  \u251c\u2500 config.py\n\u2502  \u251c\u2500 domain\n\u2502  \u251c\u2500 root_module.py\n\u2502  \u251c\u2500 server.py\n\u2502  \u251c\u2500 __init__.py\n\u251c\u2500 tests/\n\u2502  \u251c\u2500 __init__.py\n\u251c\u2500 pyproject.toml\n\u251c\u2500 README.md\n</code></pre> Next, in <code>db_learning/</code> directory, we need to create a <code>models.py</code>. It will hold all our SQLAlchemy ORM Models for now.</p>"},{"location":"overview/#creating-a-model","title":"Creating a Model","text":"<p>In <code>models.py</code>, we use <code>ellar_sql.model.Model</code> to create our SQLAlchemy ORM Models.</p> db_learning/model.py<pre><code>from ellar_sql import model\n\n\nclass User(model.Model):\n    id: model.Mapped[int] = model.mapped_column(model.Integer, primary_key=True)\n    username: model.Mapped[str] = model.mapped_column(model.String, unique=True, nullable=False)\n    email: model.Mapped[str] = model.mapped_column(model.String)\n</code></pre> <p>Info</p> <p><code>ellar_sql.model</code> also exposes <code>sqlalchemy</code>, <code>sqlalchemy.orm</code> and <code>sqlalchemy.event</code> imports just for ease of import reference</p>"},{"location":"overview/#create-a-usercontroller","title":"Create A UserController","text":"<p>Let's create a controller that exposes our user data.</p> db_learning/controller.py<pre><code>import ellar.common as ecm\nfrom ellar.pydantic import EmailStr\nfrom ellar_sql import model, get_or_404\nfrom .models import User\n\n\n@ecm.Controller\nclass UsersController(ecm.ControllerBase):\n    @ecm.post(\"/users\")\n    def create_user(self, username: ecm.Body[str], email: ecm.Body[EmailStr], session: ecm.Inject[model.Session]):\n        user = User(username=username, email=email)\n\n        session.add(user)\n        session.commit()\n        session.refresh(user)\n\n        return user.dict()\n\n    @ecm.get(\"/users/{user_id:int}\")\n    def user_by_id(self, user_id: int):\n        user = await get_or_404(User, user_id)\n        return user.dict()\n\n    @ecm.get(\"/\")\n    async def user_list(self, session: ecm.Inject[model.Session]):\n        stmt = model.select(User)\n        rows = session.execute(stmt.offset(0).limit(100)).scalars()\n        return [row.dict() for row in rows]\n\n    @ecm.get(\"/{user_id:int}\")\n    async def user_delete(self, user_id: int, session: ecm.Inject[model.Session]):\n        user = await get_or_404(User, user_id)\n        session.delete(user)\n        return {'detail': f'User id={user_id} Deleted successfully'}\n</code></pre>"},{"location":"overview/#ellarsqlmodule-setup","title":"EllarSQLModule Setup","text":"<p>In the <code>root_module.py</code> file, two main tasks need to be performed:</p> <ol> <li>Register the <code>UsersController</code> to make the <code>/users</code> endpoint available when starting the application.</li> <li>Configure the <code>EllarSQLModule</code>, which will set up and register essential services such as <code>EllarSQLService</code>, <code>Session</code>, and <code>Engine</code>.</li> </ol> db_learning/root_module.py<pre><code>from ellar.common import Module, exception_handler, IExecutionContext, JSONResponse, Response, IApplicationStartup\nfrom ellar.app import App\nfrom ellar.core import ModuleBase\nfrom ellar_sql import EllarSQLModule, EllarSQLService\nfrom .controller import UsersController\n\n@Module(\n    modules=[EllarSQLModule.setup(\n        databases={\n            'default': {\n                'url': 'sqlite:///app.db',\n                'echo': True\n            }\n        },\n        migration_options={'directory': 'migrations'}\n    )],\n    controllers=[UsersController]\n)\nclass ApplicationModule(ModuleBase, IApplicationStartup):\n    async def on_startup(self, app: App) -&gt; None:\n        db_service = app.injector.get(EllarSQLService)\n        db_service.create_all()\n\n    @exception_handler(404)\n    def exception_404_handler(cls, ctx: IExecutionContext, exc: Exception) -&gt; Response:\n        return JSONResponse(dict(detail=\"Resource not found.\"), status_code=404)\n</code></pre> <p>In the provided code snippet:</p> <ul> <li> <p>We registered <code>UserController</code> and <code>EllarSQLModule</code> with specific configurations for the database and migration options. For more details on <code>EllarSQLModule</code> configurations.</p> </li> <li> <p>In the <code>on_startup</code> method, we obtained the <code>EllarSQLService</code> from the Ellar Dependency Injection container using <code>EllarSQLModule</code>. Subsequently, we invoked the <code>create_all()</code> method to generate the necessary SQLAlchemy tables.</p> </li> </ul> <p>With these configurations, the application is now ready for testing. <pre><code>ellar runserver --reload\n</code></pre> Additionally, please remember to uncomment the configurations for the <code>OpenAPIModule</code> in the <code>server.py</code>  file to enable visualization and interaction with the <code>/users</code> endpoint.</p> <p>Once done,  you can access the OpenAPI documentation at http://127.0.0.1:8000/docs.</p> <p>You can find the source code for this project  here.</p>"},{"location":"overview/configuration/","title":"EllarSQLModule Config","text":"<p><code>EllarSQLModule</code> is an Ellar Dynamic Module that offers two ways of configuration:</p> <ul> <li><code>EllarSQLModule.register_setup()</code>: This method registers a <code>ModuleSetup</code> that depends on the application config.</li> <li><code>EllarSQLModule.setup()</code>: This method immediately sets up the module with the provided options.</li> </ul> <p>While we've explored many examples using <code>EllarSQLModule.setup()</code>, this section will focus on the usage of <code>EllarSQLModule.register_setup()</code>.</p> <p>Before delving into that, let's first explore the setup options available for <code>EllarSQLModule</code>.</p>"},{"location":"overview/configuration/#ellarsqlmodule-configuration-parameters","title":"EllarSQLModule Configuration Parameters","text":"<ul> <li> <p>databases: typing.Union[str, typing.Dict[str, typing.Any]]:</p> <p>This field describes the options for your database engine, utilized by SQLAlchemy Engine, Metadata, and Sessions. There are three methods for setting these options, as illustrated below: <pre><code>## CASE 1\ndatabases = \"sqlite//:memory:\"\n# This will result to \n# databases = {\n#     'default': {\n#         'url': 'sqlite//:memory:'\n#     }\n# }\n\n## CASE 2\ndatabases = {\n    'default': \"sqlite//:memory:\",\n    'db2': \"sqlite//:memory:\",\n}\n# This will result to \n# databases = {\n#     'default': {\n#         'url': 'sqlite//:memory:'\n#     },\n#     'db2': {\n#         'url': 'sqlite//:memory:'\n#     },\n# }\n\n## CASE 3 - With Extra Engine Options\ndatabases = {\n    'default': {\n        \"url\": \"sqlite//:memory:\",\n        \"echo\": True,\n        \"connect_args\": {\n            \"check_same_thread\": False\n        }\n    }\n}\n</code></pre></p> </li> <li> <p>migration_options: typing.Union[typing.Dict[str, typing.Any], MigrationOption]:   The migration options can be specified either in a dictionary object or as a <code>MigrationOption</code> schema instance.    These configurations are essential for defining the necessary settings for database migrations. The available options include:</p> <ul> <li>directory=<code>migrations</code>:directory to save alembic migration templates/env and migration versions</li> <li>use_two_phase=<code>True</code>: bool value that indicates use of two in migration SQLAlchemy session</li> <li> <p>context_configure=<code>{compare_type: True, render_as_batch: True, include_object: callable}</code>:      key-value pair that will be passed to <code>EnvironmentContext.configure</code>.</p> <p>Default context_configure set by EllarSQL:</p> <ul> <li>compare_type=True: This option configures the automatic migration generation subsystem to detect column type changes.</li> <li>render_as_batch=True: This option generates migration scripts using batch mode, an operational mode that works around limitations of many ALTER commands in the SQLite database by implementing a \u201cmove and copy\u201d workflow.</li> <li>include_object: Skips model from auto gen when it's defined in table args eg: <code>__table_args__ = {\"info\": {\"skip_autogen\": True}}</code></li> </ul> </li> </ul> </li> <li> <p>session_options: t.Optional[t.Dict[str, t.Any]]:</p> <p>A default key-value pair pass to SQLAlchemy.Session() when creating a session.</p> </li> <li> <p>engine_options: t.Optional[t.Dict[str, t.Any]]:</p> <p>A default key-value pair to pass to every database configuration engine configuration for SQLAlchemy.create_engine().</p> <p>This overriden by configurations provided in <code>databases</code> parameters</p> </li> <li> <p>models: t.Optional[t.List[str]]: list of python modules that defines <code>model.Model</code> models. By providing this, EllarSQL ensures models are discovered before Alembic CLI migration actions or any other database interactions with SQLAlchemy.</p> </li> <li> <p>echo: bool: The default value for <code>echo</code> and <code>echo_pool</code> for every engine. This is useful to quickly debug the connections and queries issued from SQLAlchemy.</p> </li> <li> <p>root_path: t.Optional[str]: The <code>root_path</code> for sqlite databases and migration base directory. Defaults to the execution path of <code>EllarSQLModule</code> </p> </li> </ul>"},{"location":"overview/configuration/#connection-url-format","title":"Connection URL Format","text":"<p>Refer to SQLAlchemy\u2019s documentation on Engine Configuration for a comprehensive overview of syntax, dialects, and available options.</p> <p>The standard format for a basic database connection URL is as follows: Username, password, host, and port are optional  parameters based on the database type and specific configuration. <pre><code>dialect://username:password@host:port/database\n</code></pre> Here are some example connection strings: <pre><code># SQLite, relative to Flask instance path\nsqlite:///project.db\n\n# PostgreSQL\npostgresql://scott:tiger@localhost/project\n\n# MySQL / MariaDB\nmysql://scott:tiger@localhost/project\n</code></pre></p>"},{"location":"overview/configuration/#default-driver-options","title":"Default Driver Options","text":"<p>To enhance usability for web applications, default options have been configured for SQLite and MySQL engines.</p> <p>For SQLite, relative file paths are now relative to the <code>root_path</code> option rather than the current working directory.  Additionally, in-memory databases utilize a static <code>pool</code> and <code>check_same_thread</code> to ensure seamless operation across multiple requests.</p> <p>For <code>MySQL</code> (and <code>MariaDB</code>) servers, a default idle connection timeout of 8 hours has been set. This configuration helps avoid errors,  such as 2013: Lost connection to <code>MySQL</code> server during query. To preemptively recreate connections before hitting this timeout,  a default <code>pool_recycle</code> value of 2 hours (7200 seconds) is applied.</p>"},{"location":"overview/configuration/#timeout","title":"Timeout","text":"<p>Certain databases, including <code>MySQL</code> and <code>MariaDB</code>, might be set to close inactive connections after a certain duration,  which can lead to errors like 2013: Lost connection to MySQL server during query.  While this behavior is configured by default in MySQL and MariaDB, it could also be implemented by other database services.</p> <p>If you encounter such errors, consider adjusting the pool_recycle option in the engine settings to a value less than the database's timeout.</p> <p>Alternatively, you can explore setting pool_pre_ping if you anticipate frequent closure of connections,  especially in scenarios like running the database in a container that may undergo periodic restarts.</p> <p>For more in-depth information on dealing with disconnects,  refer to SQLAlchemy's documentation on handling connection issues.</p>"},{"location":"overview/configuration/#ellarsqlmodule-registersetup","title":"EllarSQLModule RegisterSetup","text":"<p>As mentioned earlier, EllarSQLModule can be configured from the application through <code>EllarSQLModule.register_setup</code>.  This process registers a ModuleSetup factory that depends on the Application Config object.  The factory retrieves the <code>ELLAR_SQL</code> attribute from the config and validates the data before passing it to <code>EllarSQLModule</code> for setup.</p> <p>It's essential to note  that <code>ELLAR_SQL</code> will be a dictionary object with the configuration parameters  mentioned above as keys.</p> <p>Here's a quick example: db_learning/root_module.py<pre><code>from ellar.common import Module, exception_handler, IExecutionContext, JSONResponse, Response, IApplicationStartup\nfrom ellar.app import App\nfrom ellar.core import ModuleBase\nfrom ellar_sql import EllarSQLModule, EllarSQLService\nfrom .controller import UsersController\n\n\n@Module(\n    modules=[EllarSQLModule.register_setup()],\n    controllers=[UsersController]\n)\nclass ApplicationModule(ModuleBase, IApplicationStartup):\n    async def on_startup(self, app: App) -&gt; None:\n        db_service = app.injector.get(EllarSQLService)\n        db_service.create_all()\n\n    @exception_handler(404)\n    def exception_404_handler(cls, ctx: IExecutionContext, exc: Exception) -&gt; Response:\n        return JSONResponse(dict(detail=\"Resource not found.\"), status_code=404)\n</code></pre> Let's update <code>config.py</code>.</p> <p><pre><code>import typing as t\n...\n\nclass DevelopmentConfig(BaseConfig):\n    DEBUG: bool = True\n\n    ELLAR_SQL: t.Dict[str, t.Any] = {\n        'databases': {\n            'default': 'sqlite:///app.db',\n        },\n        'echo': True,\n        'migration_options': {\n            'directory': 'migrations' # root directory will be determined based on where the module is instantiated.\n        },\n        'models': []\n    }\n</code></pre> The registered ModuleSetup factory reads the <code>ELLAR_SQL</code> value and configures the <code>EllarSQLModule</code> appropriately.</p> <p>This approach is particularly useful when dealing with multiple environments.  It allows for seamless modification of the ELLAR_SQL values in various environments such as  Continuous Integration (CI), Development, Staging, or Production.  You can easily change the settings for each environment  and export the configurations as a string to be imported into <code>ELLAR_CONFIG_MODULE</code>.</p>"},{"location":"pagination/","title":"Pagination","text":"<p>Pagination is a common practice for large datasets,  enhancing user experience by breaking content into manageable pages.  It optimizes load times and navigation and allows users to explore extensive datasets with ease  while maintaining system performance and responsiveness.</p> <p>EllarSQL offers two styles of pagination:</p> <ul> <li>PageNumberPagination: This pagination internally configures items <code>per_page</code> and max item size (<code>max_size</code>) and, allows users to set the <code>page</code> property.</li> <li>LimitOffsetPagination: This pagination internally configures max item size (<code>max_limit</code>) and, allows users to set the <code>limit</code> and <code>offset</code> properties.</li> </ul> <p>EllarSQL pagination is activated when a route function is decorated with <code>paginate</code> function. The result of the route function is expected to be a <code>SQLAlchemy.sql.Select</code> instance or a <code>Model</code> type.</p> <p>For example:</p> <pre><code>import ellar.common as ec\nfrom ellar_sql import model, paginate\nfrom .models import User\nfrom .schemas import UserSchema\n\n\n@ec.get('/users')\n@paginate(item_schema=UserSchema)\ndef list_users():\n    return model.select(User)\n</code></pre>"},{"location":"pagination/#paginate-properties","title":"paginate properties","text":"<ul> <li>pagination_class: t.Optional[t.Type[PaginationBase]]=None: specifies pagination style to use. if not set, it will be set to <code>PageNumberPagination</code></li> <li>model: t.Optional[t.Type[ModelBase]]=None: specifies a <code>Model</code> type to get list of data. If set, route function can return <code>None</code> or override by returning a select/filtered statement</li> <li>as_template_context: bool=False: indicates that the paginator object be added to template context. See Template Pagination</li> <li>item_schema: t.Optional[t.Type[BaseModel]]=None: This is required if <code>template_context</code> is False. It is used to serialize the SQLAlchemy model and create a response-schema/docs.</li> <li>paginator_options:t.Any: keyword argument for configuring <code>pagination_class</code> set to use for pagination.</li> </ul>"},{"location":"pagination/#api-pagination","title":"API Pagination","text":"<p>API pagination simply means pagination in an API route function. This requires <code>item_schema</code> for the paginate decorator to create a <code>200</code> response documentation for the decorated route and for the paginated result to be serialized to json.</p> <p><pre><code>import ellar.common as ec\nfrom ellar_sql import paginate\nfrom .models import User\n\n\nclass UserSchema(ec.Serializer):\n    id: int\n    username: str\n    email: str\n\n\n@ec.get('/users')\n@paginate(item_schema=UserSchema, per_page=100)\ndef list_users():\n    return User\n</code></pre> We can also rewrite the illustration above since we are not making any modification to the User query.</p> <pre><code>...\n\n@ec.get('/users')\n@paginate(model=User, item_schema=UserSchema)\ndef list_users():\n    pass\n</code></pre>"},{"location":"pagination/#template-pagination","title":"Template Pagination","text":"<p>This is for route functions decorated with <code>render</code> function that need to be paginated. For this to happen, <code>paginate</code> function need to return a context and this is achieved by setting <code>as_template_context=True</code></p> <p><pre><code>import ellar.common as ec\nfrom ellar_sql import model, paginate\nfrom .models import User\n\n\n@ec.get('/users')\n@ec.render('list.html')\n@paginate(as_template_context=True)\ndef list_users():\n    return model.select(User), {'name': 'Template Pagination'} # pagination model, template context\n</code></pre> In the illustration above, a tuple of select statement and a template context was returned. The template context will be updated with a <code>paginator</code> as an extra key by the <code>paginate</code> function before been processed by <code>render</code> function.</p> <p>We can re-write the example above to return just the template context since there is no form of  filter directly affecting the <code>User</code> model query. <pre><code>...\n\n@ec.get('/users')\n@ec.render('list.html')\n@paginate(model=model.select(User), as_template_context=True)\ndef list_users():\n    return {'name': 'Template Pagination'}\n</code></pre> Also, in the <code>list.html</code> we have the following codes: <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;h3&gt;{{ name }}&lt;/h3&gt;\n{% macro render_pagination(paginator, endpoint) %}\n  &lt;div&gt;\n    {{ paginator.first }} - {{ paginator.last }} of {{ paginator.total }}\n  &lt;/div&gt;\n  &lt;div&gt;\n    {% for page in paginator.iter_pages() %}\n      {% if page %}\n        {% if page != paginator.page %}\n          &lt;a href=\"{{ url_for(endpoint) }}?page={{page}}\"&gt;{{ page }}&lt;/a&gt;\n        {% else %}\n          &lt;strong&gt;{{ page }}&lt;/strong&gt;\n        {% endif %}\n      {% else %}\n        &lt;span class=ellipsis&gt;\u2026&lt;/span&gt;\n      {% endif %}\n    {% endfor %}\n  &lt;/div&gt;\n{% endmacro %}\n\n&lt;ul&gt;\n  {% for user in paginator %}\n    &lt;li&gt;{{ user.id }} @ {{ user.name }}\n  {% endfor %}\n&lt;/ul&gt;\n{{render_pagination(paginator=paginator, endpoint=\"list_users\") }}\n&lt;/html&gt;\n</code></pre></p> <p>The <code>paginator</code> object in the template context has a <code>iter_pages()</code> method which produces up to three group of numbers, seperated by <code>None</code>. </p> <p>It defaults to showing 2 page numbers at either edge,  2 numbers before the current, the current, and 4 numbers after the current.  For example, if there are 20 pages and the current page is 7, the following values are yielded. <pre><code>paginator.iter_pages()\n[1, 2, None, 5, 6, 7, 8, 9, 10, 11, None, 19, 20]\n</code></pre> The <code>total</code> attribute showcases the total number of results, while <code>first</code> and <code>last</code> display the range of items on the current page. </p> <p>The accompanying Jinja macro renders a simple pagination widget. <pre><code>{% macro render_pagination(paginator, endpoint) %}\n  &lt;div&gt;\n    {{ paginator.first }} - {{ paginator.last }} of {{ paginator.total }}\n  &lt;/div&gt;\n  &lt;div&gt;\n    {% for page in paginator.iter_pages() %}\n      {% if page %}\n        {% if page != paginator.page %}\n          &lt;a href=\"{{ url_for(endpoint) }}?page={{page}}\"&gt;{{ page }}&lt;/a&gt;\n        {% else %}\n          &lt;strong&gt;{{ page }}&lt;/strong&gt;\n        {% endif %}\n      {% else %}\n        &lt;span class=ellipsis&gt;\u2026&lt;/span&gt;\n      {% endif %}\n    {% endfor %}\n  &lt;/div&gt;\n{% endmacro %}\n</code></pre></p>"},{"location":"testing/","title":"Testing EllarSQL Models","text":"<p>There are various approaches to testing SQLAlchemy models, but in this section, we will focus on setting  up a good testing environment for EllarSQL models using the  Ellar Test factory and pytest.</p> <p>For an effective testing environment, it is recommended to utilize the <code>EllarSQLModule.register_setup()</code>  approach to set up the EllarSQLModule. This allows you to add a new configuration for <code>ELLAR_SQL</code>  specific to your testing database, preventing interference with production or any other databases in use.</p>"},{"location":"testing/#defining-testconfig","title":"Defining TestConfig","text":"<p>There are various methods for configuring test settings in Ellar,  as outlined  here. However, in this section, we will adopt the 'in a file' approach.</p> <p>Within the <code>db_learning/config.py</code> file, include the following code:</p> db_learning/config.py<pre><code>import typing as t\n...\n\nclass DevelopmentConfig(BaseConfig):\n    DEBUG: bool = True\n    # Configuration through Config\n    ELLAR_SQL: t.Dict[str, t.Any] = {\n        'databases': {\n            'default': 'sqlite:///project.db',\n        },\n        'echo': True,\n        'migration_options': {\n            'directory': 'migrations'\n        },\n        'models': ['models']\n    }\n\nclass TestConfig(BaseConfig):\n    DEBUG = False\n\n    ELLAR_SQL: t.Dict[str, t.Any] = {\n        **DevelopmentConfig.ELLAR_SQL, \n        'databases': {\n            'default': 'sqlite:///test.db',\n        },\n        'echo': False,\n    }\n</code></pre> <p>This snippet demonstrates the 'in a file' approach to setting up the <code>TestConfig</code> class within the same <code>db_learning/config.py</code> file.</p>"},{"location":"testing/#changes-made","title":"Changes made:","text":"<ol> <li>Updated the <code>databases</code> section to use <code>sqlite+aiosqlite:///test.db</code> for the testing database.</li> <li>Set <code>echo</code> to <code>True</code> to enable SQLAlchemy output during testing for cleaner logs.</li> <li>Preserved the <code>migration_options</code> and <code>models</code> configurations from <code>DevelopmentConfig</code>.</li> </ol> <p>Also, feel free to further adjust it based on your specific testing requirements!</p>"},{"location":"testing/#test-fixtures","title":"Test Fixtures","text":"<p>After defining <code>TestConfig</code>, we need to add some pytest fixtures to set up EllarSQLModule and another one  that returns a <code>session</code> for testing purposes. Additionally, we need to export <code>ELLAR_CONFIG_MODULE</code>  to point to the newly defined TestConfig.</p> tests/conftest.py<pre><code>import os\nimport pytest\nfrom ellar.common.constants import ELLAR_CONFIG_MODULE\nfrom ellar.testing import Test\nfrom ellar_sql import EllarSQLService\nfrom db_learning.root_module import ApplicationModule\n\n# Setting the ELLAR_CONFIG_MODULE environment variable to TestConfig\nos.environ.setdefault(ELLAR_CONFIG_MODULE, \"db_learning.config:TestConfig\")\n\n# Fixture for creating a test module\n@pytest.fixture(scope='session')\ndef tm():\n    test_module = Test.create_test_module(modules=[ApplicationModule])\n    yield test_module\n\n# Fixture for creating a database session for testing\n@pytest.fixture(scope='session')\ndef db(tm):\n    db_service = tm.get(EllarSQLService)\n\n    # Creating all tables\n    db_service.create_all()\n\n    yield\n\n    # Dropping all tables after the tests\n    db_service.drop_all()\n\n# Fixture for creating a database session for testing\n@pytest.fixture(scope='session')\ndef db_session(db, tm):\n    db_service = tm.get(EllarSQLService)\n\n    yield db_service.session_factory()\n\n    # Removing the session factory\n    db_service.session_factory.remove()\n</code></pre> <p>The provided fixtures help in setting up a testing environment for EllarSQL models.  The <code>Test.create_test_module</code> method creates a TestModule for initializing your Ellar application,  and the <code>db_session</code> fixture initializes a database session for testing, creating and dropping tables as needed. </p> <p>If you are working with asynchronous database drivers, you can convert <code>db_session</code>  into an async function to handle coroutines seamlessly.</p>"},{"location":"testing/#alembic-migration-with-test-fixture","title":"Alembic Migration with Test Fixture","text":"<p>In cases where there are already generated database migration files, and there is a need to apply migrations during testing, this can be achieved as shown in the example below:</p> tests/conftest.py<pre><code>import os\nimport pytest\nfrom ellar.common.constants import ELLAR_CONFIG_MODULE\nfrom ellar.testing import Test\nfrom ellar_sql import EllarSQLService\nfrom ellar_sql.cli.handlers import CLICommandHandlers\nfrom db_learning.root_module import ApplicationModule\n\n# Setting the ELLAR_CONFIG_MODULE environment variable to TestConfig\nos.environ.setdefault(ELLAR_CONFIG_MODULE, \"db_learning.config:TestConfig\")\n\n# Fixture for creating a test module\n@pytest.fixture(scope='session')\ndef tm():\n    test_module = Test.create_test_module(modules=[ApplicationModule])\n    yield test_module\n\n\n# Fixture for creating a database session for testing\n@pytest.fixture(scope='session')\nasync def db(tm):\n    db_service = tm.get(EllarSQLService)\n\n    # Applying migrations using Alembic\n    async with tm.create_application().application_context():\n        cli = CLICommandHandlers(db_service)\n        cli.migrate()\n\n    yield\n\n    # Downgrading migrations after testing\n    async with tm.create_application().application_context():\n        cli = CLICommandHandlers(db_service)\n        cli.downgrade()\n\n# Fixture for creating an asynchronous database session for testing\n@pytest.fixture(scope='session')\nasync def db_session(db, tm):\n    db_service = tm.get(EllarSQLService)\n\n    yield db_service.session_factory()\n\n    # Removing the session factory\n    db_service.session_factory.remove()\n</code></pre> <p>The <code>CLICommandHandlers</code> class wraps all <code>Alembic</code> functions executed through the Ellar command-line interface.  It can be used in conjunction with the application context to initialize all model tables during testing as shown in the illustration above.  <code>db_session</code> pytest fixture also ensures that migrations are applied and then downgraded after testing,  maintaining a clean and consistent test database state.</p>"},{"location":"testing/#testing-a-model","title":"Testing a Model","text":"<p>After setting up the testing database and creating a session, let's test the insertion of a user model into the database.</p> <p>In <code>db_learning/models.py</code>, we have a user model:</p> db_learning/model.py<pre><code>from ellar_sql import model\n\nclass User(model.Model):\n    id: model.Mapped[int] = model.mapped_column(model.Integer, primary_key=True)\n    username: model.Mapped[str] = model.mapped_column(model.String, unique=True, nullable=False)\n    email: model.Mapped[str] = model.mapped_column(model.String)\n</code></pre> <p>Now, create a file named <code>test_user_model.py</code>:</p> tests/test_user_model.py<pre><code>import pytest\nimport sqlalchemy.exc as sa_exc\nfrom db_learning.models import User\n\ndef test_username_must_be_unique(db_session):\n    # Creating and adding the first user\n    user1 = User(username='ellarSQL', email='ellarsql@gmail.com')\n    db_session.add(user1)\n    db_session.commit()\n\n    # Attempting to add a second user with the same username\n    user2 = User(username='ellarSQL', email='ellarsql2@gmail.com')\n    db_session.add(user2)\n\n    # Expecting an IntegrityError due to unique constraint violation\n    with pytest.raises(sa_exc.IntegrityError):\n        db_session.commit()\n</code></pre> <p>In this test, we are checking whether the unique constraint on the <code>username</code>  field is enforced by attempting to insert two users with the same username.  The test expects an <code>IntegrityError</code> to be raised, indicating a violation of the unique constraint.  This ensures that the model behaves correctly and enforces the specified uniqueness requirement.</p>"},{"location":"testing/#testing-factory-boy","title":"Testing Factory Boy","text":"<p>factory-boy provides a convenient and flexible way to create mock objects, supporting various ORMs like Django, MongoDB, and SQLAlchemy. EllarSQL extends <code>factory.alchemy.SQLAlchemy</code> to offer a Model factory solution compatible with both synchronous and asynchronous database drivers.</p> <p>To get started, you need to install <code>factory-boy</code>:</p> <pre><code>pip install factory-boy\n</code></pre> <p>Now, let's create a factory for our user model in <code>tests/factories.py</code>:</p> tests/factories.py<pre><code>import factory\nfrom db_learning.models import User\nfrom ellar.app import current_injector\nfrom sqlalchemy.orm import Session\n\nfrom ellar_sql.factory import SESSION_PERSISTENCE_FLUSH, EllarSQLFactory\n\n\ndef _get_session():\n    session = current_injector.get(Session)\n    return session\n\nclass UserFactory(EllarSQLFactory):\n    class Meta:\n        model = User\n        sqlalchemy_session_persistence = SESSION_PERSISTENCE_FLUSH\n        sqlalchemy_session_factory = _get_session\n\n    username = factory.Faker('username')\n    email = factory.Faker('email')\n</code></pre> <p>The <code>UserFactory</code> depends on a database Session as you see from <code>_get_session()</code> function. We need to ensure that test fixture provides <code>ApplicationContext</code> for <code>current_injector</code> to work.</p> <p>So in <code>tests/conftest.py</code>, we make <code>tm</code> test fixture to run application context:</p> tests/conftest.py<pre><code>import os\n\nimport pytest\nfrom db_learning.root_module import ApplicationModule\nfrom ellar.common.constants import ELLAR_CONFIG_MODULE\nfrom ellar.testing import Test\nfrom ellar.threading.sync_worker import execute_async_context_manager\n\nfrom ellar_sql import EllarSQLService\n\nos.environ.setdefault(ELLAR_CONFIG_MODULE, \"db_learning.config:TestConfig\")\n\n@pytest.fixture(scope='session')\ndef tm():\n    test_module = Test.create_test_module(modules=[ApplicationModule])\n    app = test_module.create_application()\n\n    with execute_async_context_manager(app.application_context()):\n        yield test_module\n\n# Fixture for creating a database session for testing\n@pytest.fixture(scope='session')\ndef db(tm):\n    db_service = tm.get(EllarSQLService)\n\n    # Creating all tables\n    db_service.create_all()\n\n    yield\n\n    # Dropping all tables after the tests\n    db_service.drop_all()\n</code></pre> <p>With this setup, we can rewrite our <code>test_username_must_be_unique</code> test using <code>UserFactory</code> and <code>factory_session</code>:</p> tests/test_user_model.py<pre><code>import pytest\nimport sqlalchemy.exc as sa_exc\nfrom .factories import UserFactory\n\ndef test_username_must_be_unique(factory_session):\n    user1 = UserFactory()\n    with pytest.raises(sa_exc.IntegrityError):\n        UserFactory(username=user1.username)\n</code></pre> <p>This test yields the same result as before.  Refer to the factory-boy documentation  for more features and tutorials.</p>"}]}